## Что такое «Невод»

«Невод» — это одновременно язык и технология для поиска в тексте совпадений с шаблонами. «Невод» специально разработан для быстрого выявления сущностей и их отношений в текстах на естественном языке. Эта уникальная технология с открытым исходным кодом имеет следующие отличия.

- Язык определения шаблонов «Невод» ориентирован на контент-аналитиков, т.е. не только программистов, и позволяет создавать шаблоны, которые легко писать, читать, изменять и поддерживать.
- Шаблоны оперируют над текстовыми лексемами, такими как слова, пробелы и знаки препинания, а не над отдельными символами текста, такими как буквы и цифры.
- Шаблон может состоять из произвольных последовательностей, вариативностей, повторений, соединений, промежутков, включений, пересечений и других комбинаций текстовых лексем и других шаблонов.
- Поиск совпадений всех шаблонов выполняется за один проход по тексту. Это значительно быстрее, чем в случае использования хорошо известных регулярных выражений, причём скорость поиска не уменьшается линейно при добавлении шаблонов.
- Шаблоны нейтральны к языку текста и безопасны для использования конечными пользователями в Интернете. Поиск никогда не заблокирует работу пользователя из-за бесконечного или слишком долгого выполнения.

Язык определения шаблонов прост и понятен, поэтому его очень легко выучить.

## Основные возможности «Невода»

Этот учебник помогает изучить следующие возможности «Невода»:

- поиск текста на основе лексем с учётом прописных и строчных букв, длин слов и начал слов;
- операторы для поиска последовательностей, вариативностей, повторений, соединений, промежутков и других комбинаций лексем и шаблонов;
- мощные операторы для проверки включений, исключений и пересечений;
- составные имена шаблонов и подчинённые шаблоны;
- поля шаблонов, извлечение текста в поля и использование значений полей в операторах;
- пространства имён шаблонов и цели поиска, основанные на пространстве имён;
- многократно используемые пакеты шаблонов;
- библиотеку часто используемых шаблонов для поиска интернет-ссылок, почтовых адресов, номеров банковских карт, значений даты и времени и др.

## Разделение текста на лексемы

Шаблоны «Невода» работают на уровне лексем. Текст, в котором выполняется поиск совпадений с шаблонами, разбивается на лексемы. Лексемы делятся на слова и разделители слов. Слова - это непрерывные последовательности букв и цифр. Разделители слов - это знаки препинания, неалфавитные символы, разделители строк и пробелы. Существуют искусственные лексемы начала и конца текста, облегчающие создание шаблонов с ограниченной областью действия.

## Шаблоны

Каждый шаблон представляет собой формальную грамматику, состоящую из имени шаблона, знака равенства и выражения шаблона, оперирующего над текстовыми лексемами и ссылками на другие шаблоны. Определение шаблона заканчивается точкой с запятой. Вот, например, простейший шаблон, который ищет слово `Незабудка` в тексте:

```nevod
Компания = "Незабудка";
```

Шаблон `Компания` считается нецелевым шаблоном, т.е. совпадения с этим шаблоном не включаются в результаты поиска. Если нужно, чтобы совпадения с шаблоном были включены в результаты поиска, укажите перед именем шаблона хэш-тег, например:

```nevod
#Компания = "Незабудка";
```

Шаблон, отмеченный хэш-тегом (символом `#`), считается целевым шаблоном или тегом. Совпадения с целевыми шаблонами включаются в результаты поиска.

Если шаблон определен в пакете шаблонов (пакеты описанном ниже в этом учебнике), то определение шаблона должно начинаться с ключевого слова `@шаблон`, например:

```nevod
@шаблон #Компания = "Незабудка";
```

Обратите внимание, что все ключевые слова «Невода» начинаются с символа `@` (коммерческое «эт»). Это сделано для того, чтобы избежать зарезервированных слов и разрешить использовать любые обычные слова для именования шаблонов. Например, можно создать шаблон с именем `шаблон`:

```nevod
@шаблон шаблон = ?("@шаблон" + Пробел) + ?"#" + БуквыЦифры;
```

Используя синтаксис пакета шаблонов, можно определить шаблон как нецелевой и объявить его как цель поиска отдельно от определения шаблона, например:

```nevod
@шаблон Компания = "Незабудка";

@искать Компания;
```

Шаблон `Компания` в примере сначала определён через образец текста, а затем объявлен в качестве цели поиска с помощью ключевого слова `@искать`. Ключевое слово `@искать` можно использовать также вместо хэш-тега для объявления цели поиска, например:

```nevod
@искать @шаблон Компания = "Незабудка";
```

## Образцы текста

Шаблон может включать образцы текста или полностью состоять из образца текста. Образцы текста записываются в кавычках, как в уже упомянутом примере:

```nevod
#Компания = "Незабудка";
```

Этот шаблон ищет в тексте отдельное слово `Незабудка`, но не часть слова (не подстроку). Слова сравниваются без учета прописных и строчных букв. Чтобы включить сравнение с учетом прописных и строчных букв, укажите восклицательный знак после заключительной кавычки, например:

```nevod
#Компания = "Незабудка"!;
```

Можно также использовать одинарные кавычки вместо двойных кавычек для обозначения образцов текста:

```nevod
#Компания = 'Незабудка'!;
```

Образцы текста в кавычках рассматривается как последовательность лексем. Если образец текста содержит пробелы, знаки препинания или неалфавитные символы, он разбивается на лексемы и сравнивается последовательно лексема за лексемой с лексемами текста. Например, следующий шаблон ищет в тексте слово `Незабудка`, за которым следует пробел и слово `Софтвер`:


```nevod
#Компания = "Незабудка Софтвер";
```

Этот шаблон неявно состоит из последовательности лексем, поэтому давайте подробнее рассмотрим последовательности.

## Последовательности

Вы уже познакомились с последовательностью на примере следующего шаблона, состоящего из образца текста:

```nevod
#Компания = "Незабудка Софтвер";
```

Этот шаблон представляет собой неявную последовательность более простых текстовых лексем. Давайте перепишем его как явную последовательность:

```nevod
#Компания = "Незабудка" + Пробел + "Софтвер";
```

Последовательность обозначается знаком плюс (`+`) и в приведённом выше примере состоит из трех элементов: слова `Незабудка`, пробела и слова `Софтвер`. `Пробел` - это предопределенный шаблон, который обозначает один или несколько символов пробела, символов табуляции или символов без начертания.

Приведенный выше шаблон совпадает с текстом `Незабудка Софтвер`, но не совпадает с текстом `Незабудка Софт`. Чтобы искать совпадения с различными вариантами написания какой-либо сущности, нужно использовать вариативность.

## Вариативности

Следующий шаблон состоит из вариативности и ищет либо текст `Незабудка Софтвер`, либо текст `Незабудка Софт`:

```nevod
#Компания = {"Незабудка Софтвер", "Незабудка Софт"};
```

Вариативность обозначается фигурными скобками. Альтернативы внутри вариативности разделяются запятой.

Объединив последовательность и вариативность, можно переписать последний пример следующим образом:

```nevod
#Компания = "Незабудка" + Пробел + {"Софтвер", "Софт"};
```

Приведённый выше шаблон ищет слово `Незабудка`, за которым следует пробел и либо слово `Софтвер`, либо слово `Софт`.

Вариативность может содержать исключения, которые обозначаются с помощью знака тильды (`~`). В следующем шаблоне ищется слово `Незабудка`, за которым следует пробел и любое слово из букв, кроме слов `Софтвер` и `Софт`:

```nevod
#Технология = "Незабудка" + Пробел + {Буквы, ~"Софтвер", ~"Софт"};
```

Шаблон `Буквы` - это предопределенный шаблон, который совпадает со словом, состоящим только из букв алфавита (любого языка).

С помощью вариативности можно указать, что знаки препинания (такие как точка, запятая, точка с запятой и другие), неалфавитные символы (такие как звездочка, подчеркивание, плюс и другие) и разделители строк являются разделителями слов наряду с пробелами, например:

```nevod
#Компания = "Незабудка" + {Пробел, ЗнакПрепинания, Символ, РазделительСтрок} + {"Софтвер", "Софт"};
```

Используя стандартный шаблон `РазделительСлов`, этот пример можно было бы переписать следующим образом:

```nevod
#Компания = "Незабудка" + РазделительСлов + {"Софтвер", "Софт"};
```

Шаблон `РазделительСлов` - это стандартный шаблон, который совпадает с лексемой, рассматриваемой как разделитель слова; он эквивалентен вариативности `{Пробел, ЗнакПрепинания, Символ, РазделительСтрок}`. Мы рассмотрим стандартные шаблоны в одном из последующих параграфов.

Приведённый выше шаблон не сможет найти совпадение, если между словами есть несколько разделителей слов. Чтобы искать совпадения с повторяющимися лексемами, нужно использовать повторение.

## Повторения

Следующий шаблон ищет текст с одним или несколькими (но не более девяти) повторяющимися разделителями слов между словами `Незабудка` и `Софтвер`:

```nevod
#Компания = "Незабудка" + [1-9 РазделительСлов] + "Софтвер";
```

Повторение обозначается квадратными скобками, внутри которых указывается количество повторений (в общем случае диапазон повторений) и повторяющийся элемент. В приведенном выше примере диапазон повторения `1-9` означает «от 1 до 9 раз».

Количество повторений элемента может быть не ограничено (диапазон без верхней границы), в этом случае используется следующий синтаксис:

```nevod
#Компания = "Незабудка" + [1+ РазделительСлов] + "Софтвер";
```

В этом примере числовой диапазон `1+` не имеет верхней границы и означает «один и более раз».

Обратите внимание, что в случае отсутствия верхней границы у диапазона, поисковая система может сама устанавливать верхнюю границу, чтобы предотвратить слишком длительный поиск, воспринимаемый пользователем как бесконечный.

Допускается устанавливать нижнюю границу диапазона повторений равной нулю. Это означает, что повторяющийся элемент является необязательным, т.е. может быть пропущен. Например:

```nevod
#Компания = "Незабудка" + [0-1 РазделительСлов + "Софтвер"];
```

Приведенный выше шаблон ищет текст, содержащий слово `Незабудка`, за которым необязательно следует последовательность, состоящая из разделителя слов и слова `Софтвер`.

## Необязательность

Повторение с числовым диапазоном `0-1` может быть заменено эквивалентным оператором необязательности, который обозначается знаком вопроса (`?`). Следующий шаблон эквивалентен предыдущему:

```nevod
#Компания = "Незабудка" + ?(РазделительСлов + "Софтвер");
```

Необязательный элемент после знака вопроса может быть пропущен в тексте. Обратите внимание на круглые скобки, используемые в примере для указания приоритета операторов. В отсутствие скобок оператор необязательности `?` относился бы только к элементу `РазделительСлов`, но не к последовательности, включающей также слово `Софтвер`.

## Последовательности слов

При поиске совпадений в текстах на естественном языке зачастую требуется игнорировать пробелы, знаки препинания и всё остальное, кроме слов. Например, в следующем шаблоне ищется последовательность слов `ООО`, `Незабудка` и `Софтвер` с необязательными разделителями слов между указанными словами:

```nevod
#Компания = "ООО" + [0+ РазделительСлов] + "Незабудка" + [0+ РазделительСлов] + "Софтвер";
```

С помощью оператора `_` (обозначается символом подчеркивания) этот шаблон может быть переписан в более компактной и элегантной форме:

```nevod
#Компания = "ООО" _ "Незабудка" _ "Софтвер";
```

Подчеркивание как бы заменяет часть `+ [0+ РазделительСлов] +` из предыдущего шаблона и облегчает запись последовательности слов.

## Соединения

Вы можете искать слова или другие элементы (в общем случае совпадения с другими шаблонами), которые одновременно упоминаются в тексте. Это делается с помощью оператора `&`, который называется соединением, например:

```nevod
#Продукт = "Незабудка" & "Невод"
```

Этот шаблон ищет фрагмент текста от слова `Незабудка` до слова `Невод`, независимо от порядка этих слов.

Соединения, также как последовательности, могут состоять из двух, трех или более элементов, но в отличие от последовательности соединение ищет элементы в любом порядке и на любом расстоянии между ними. Рассмотрим шаблон:

```nevod
#Продукт = "Незабудка" & "Невод" & "Служба"
```

Этот шаблон ищет совпадение с фрагментом текста, в котором упоминаются три слова `Незабудка`, `Невод` и `Служба`, независимо от порядка этих слов и расстояния между словами.

## Промежутки

Для поиска текстовых элементов в строгом порядке, но с произвольными лексемами в промежутке между ними, можно использовать оператор промежутка `...` (обозначается многоточием). Следующий пример демонстрирует использование оператора промежутка для поиска форматированного текста в HTML-документах:

```nevod
#HTML-заголовок = "<title>" ... "</title>";
```

Приведённый выше шаблон совпадает с заголовочной частью HTML-документа, начинающейся с открывающего тега `<title>` и заканчивающейся закрывающим тегом `</title>`.

В случае нескольких перекрывающихся вариантов совпадения промежутка результатом будет совпадение меньшей длины.

Существует вторая форма оператора промежутка (обозначается двойными точками), которая позволяет указать длину промежутка в словах. Эта форма может быть использована для поиска в тексте слов, которые находятся на некотором небольшом расстоянии друг от друга. Допустимое расстояние указывается в словах, где `Слово` является стандартным шаблоном. Рассмотрим пример:

```nevod
#HTML-заголовок = "<title>" .. [1-20] .. "</title>";
```

Приведённый выше шаблон совпадает, если между открывающим и закрывающим HTML-тегами заголовка имеется от одного до двадцати слов (но не более). Первая двойная точка, числовой диапазон в квадратных скобках, и вторая двойная точка обозначают оператор промежутка в словах.

Очевидно, что следующие два шаблона по смыслу эквивалентны:

```nevod
#HTML-заголовок-1 = "<title>" ... "</title>";
#HTML-заголовок-2 = "<title>" .. [0+] .. "</title>";
```

Как вы уже возможно заметили, имена шаблонов могут содержать дефисы.

## Включения, исключения и пересечения

При использовании промежутков и соединений бывает нужно ограничить область поиска совпадений в тексте. «Невод» позволяет сделать это с помощью оператора `@внутри`, который задаёт шаблон, ограничивающий область совпадения с другим шаблоном. Например:

```nevod
#Компания = "Незабудка" & "Невод" @внутри ("<title>" ... "</title>");
```

Этот шаблон ищет слова `Незабудка` и `Невод`, находящиеся **внутри** заголовка HTML-документа. Оператор `@внутри` имеет самый низкий приоритет; выражение после ключевого слова `@внутри` является шаблоном, который определяет область поиска выражения перед ключевым словом `@внутри`.

Помимо оператора `@внутри` существует оператор `@вне` с противоположным смыслом. Оператор `@вне` позволяет выполнить поиск текста с исключением, например:

```nevod
#Компания = "Незабудка" @вне "цветок незабудка";
```

Приведённый выше шаблон совпадает, если слово `Незабудка` встречается **вне** фразы `цветок незабудка`.

Существует еще один полезный оператор, который позволяет искать совпадение с шаблоном, содержащее внутри совпадение с другим шаблоном. Этот оператор называется `@содержащий`. Следующий пример демонстрирует использование оператора `@содержащий` для поиска в HTML-документе заголовка, содержащего внутри слово `Незабудка`:

```nevod
#Про-Незабудку = ("<title>" ... "</title>") @содержащий "Незабудка";
```

Разница между операторами `@содержащий` и `@внутри` заключается в том, что совпадением для оператора `@содержащий` является окружающий текст, а совпадением для оператора `@внутри` является внутренний текст.

## Стандартные шаблоны, обозначающие лексемы

Существуют предопределенные шаблоны, которые можно использовать без объявления. Они служат для поиска стандартных лексем и делятся на основные и дополнительные.

Существуют следующие основные лексемы, рассматриваемые как стандартные шаблоны:

`Слово` — любое слово, непрерывная последовательность букв алфавита (любого языка) и цифр.

`ЗнакПрепинания` — знак препинания, используемый в письменности для разделения текста на фразы, словосочетания, предложения, для выделения смысловых отрезков и других вспомогательных функций. Следующие символы считаются знаками препинания: `.`, `,`, `!`, `?`, `(`, `)`, `-`, `;`, `:`, `'`, `"`.

`Символ` — неалфавитный символ, например, один из следующих: `@`, `_`, `#`, `$`, `%`, `&`, `*`, `^`, `+`, `=`, `~`, `[`, `]`, `{`, `}`, `<`, `>`, `/`, `\`, `|`.

`Пробел` — непрерывная последовательность символов пробела, символов табуляции и символов без начертания.

`РазделительСтрок` — разделитель строк, обозначает конец текстовой строки.

`Начало` — начало текста, искусственная лексема.

`Конец` — конец текста, искусственная лексема.

Существуют следующие дополнительные лексемы, производные от основных лексем. Они тоже считаются стандартными шаблонами:

`Буквы` — буквенное `Слово`, непрерывная последовательность только букв алфавита (любого языка).

`Цифры` — цифровое `Слово`, непрерывная последовательность только цифр.

`БуквыЦифры` — буквенно-цифровое `Слово`, непрерывная последовательность букв и цифр, которая начинается с буквы.

`ЦифрыБуквы` — буквенно-цифровое `Слово`, непрерывная последовательность букв и цифр, которая начинается с цифры.

`Пропуск` — пробел или разделитель строк. Эквивалентно списку альтернатив: `{Пробел, РазделительСтрок}`.

`РазделительСлов` — любой разделитель слов, такой как пробел, знак препинания, неалфавитный символ или разделитель строк. Эквивалентно списку альтернатив: `{Пробел, ЗнакПрепинания, Символ, РазделительСтрок}`.

`Любое` — любое слово или разделитель слов, то есть любая лексема за исключением лексем `Начало` и `Конец`. Эквивалентно списку альтернатив: `{Слово, РазделительСлов}`

## Параметризованные лексемы

Стандартные шаблоны позволяют искать лексемы не только по типу, но и по длине, а также учитывать при поиске прописные и строчные буквы. Учитываемые при поиске параметры лексемы указываются в круглых скобках после имени лексемы. Например, следующий шаблон демонстрирует использование параметризованной лексемы `Цифры` для поиска телефонных номеров, состоящих из двух- и трехзначных чисел, разделенных дефисами:

```nevod
#Номер-телефона = Цифры(2-3) + "-" + Цифры(2-3) + "-" + Цифры(2-3);
```
В примере выше шаблон `Цифры(2-3)` означает «число длиной от 2-х до 3-х цифр».

Шаблон в следующем примере может быть использован для поиска сокращений, состоящих из трёх-пяти букв:

```nevod
#Сокращение = Буквы(3-5, Прописные);
```

В этом примере шаблон `Буквы(3-5, Прописные)` означает «слово длиной от 3-х до 5-ти прописных букв».

Как можно заметить, некоторые стандартные шаблоны (`Пропуск`, `РазделительСлов`, `Любое`) определены через другие шаблоны. Вы можете сделать то же самое и определить свои собственные шаблоны, выраженные через другие шаблоны. В новой версии «Невод» позволит создавать даже рекурсивные шаблоны, выраженные сами через себя.

## Шаблоны, выраженные через другие шаблоны

Вы можете почувствовать всю силу «Невода» при создании шаблонов на основе других шаблонов. Рассмотрим следующий шаблон `Интернет-ссылка`, предназначенный для поиска интернет-ссылок в тексте. Он определён через другие шаблоны:

```nevod
@шаблон #Интернет-ссылка = Схема + Домен + ?Порт + ?Путь + ?Запрос + ?Якорь;
```

Шаблон `Интернет-ссылка` определён через шесть вспомогательных шаблонов: `Схема`, `Домен`, `Порт`, `Путь`, `Запрос` и `Якорь`, которые, в свою очередь, можно определить следующим образом:

```nevod
@шаблон Схема = {'http', 'https' , 'ftp', 'mailto', 'file', 'data', 'irc'} + '://';
@шаблон Домен = Слово + [1+ '.' + Слово + [0+ {Слово, '_', '-'}]];
@шаблон Порт = ':' + Цифры;
@шаблон Путь = ?'/' + [0+ {Слово, '/', '_', '+', '-', '%', '.'}];
@шаблон Запрос = '?' + ?(Параметр + [0+ '&' + Параметр])
@шаблон Параметр = Идентификатор + '=' + Идентификатор
@шаблон Идентификатор = {Буквы, БуквыЦифры, '_'} + [0+ {Слово, '_'}];
@шаблон Якорь = '#' + Слово;
```

Порядок определения шаблонов не имеет значения. Как показано в примере выше, шаблоны могут ссылаться на другие шаблоны, определенные позже в тексте.

Некоторые шаблоны, выполняющие вспомогательную роль, могут конфликтовать по именам с другими шаблонами. Чтобы разрешить конфликты имён, вы можете определить вспомогательные шаблоны как подчинённые (вложенные) шаблоны других шаблонов. Например:

```nevod
@шаблон #Интернет-ссылка = Схема + Домен + ?Порт + ?Путь + ?Запрос + ?Якорь
@где {
  Схема = {'http', 'https' , 'ftp', 'mailto', 'file', 'data',
    'irc'} + '://';
  Домен = Слово + [1+ '.' + Слово + [0+ {Слово, '_', '-'}]];
  Порт = ':' + Цифры;
  Путь = ?'/' + [0+ {Слово, '/', '_', '+', '-', '%', '.'}];

  Запрос = '?' + ?(Параметр + [0+ '&' + Параметр])
  @где
  {
    Параметр = Идентификатор + '=' + Идентификатор
    @где
    {
      Идентификатор = {Буквы, БуквыЦифры, '_'} + [0+ {Слово, '_'}];
    };
  };

  Якорь = '#' + Слово;
};
```

В примере выше основной шаблон `Интернет-ссылка` определён через подчинённые шаблоны `Схема`, `Домен`, `Порт`, `Путь`, `Запрос` и `Якорь`, причём некоторые из подчинённых шаблонов, например `Запрос`, в свою очередь сами определены через подчинённые шаблоны.

Ключевое слово `@где`, за которым следует блок определения шаблонов в фигурных скобоках, говорит о том, что шаблоны внутри фигурных скобок являются подчинёнными по отношению к основному.

На подчинённый шаблон можно ссылаться из основного шаблона либо по его простому имени, либо по его составному имени, включающему в себя имя основного шаблона. Например, на подчинённый шаблон `Схема`, на который основной шаблон `Интернет-ссылка` ссылается по имени `Схема`, можно было бы сослаться по составному имени `Интернет-ссылка.Схема` вне определения шаблона `Интернет-ссылка`. Для создания составного имени используется знак точки (`.`).

При разрешении имён транслятор «Невода» пытается добавить имя транслируемого шаблона (`Интернет-ссылка`) к имени ссылки на шаблон (`Схема`) и ищет шаблон с составным именем (`Интернет-ссылка.Схема`), прежде чем искать шаблон с глобально уникальным именем (`Схема`).

Подчинённый шаблон может служить основным шаблоном для других подчинённых шаблонов. В приведённом выше примере шаблон `Параметр` является подчинённым для шаблона `Запрос`, который, в свою очередь, является подчинённым для шаблона `Интернет-ссылка`. Полное составное имя шаблона `Параметр` будет: `Интернет-ссылка.Запрос.Параметр`.

## Поля шаблонов и извлечение текста

Шаблоны могут иметь поля, используемые для извлечения из текста избранных частей, с которыми совпали элементы шаблона. Давайте рассмотрим поля и извлечение текста на примере шаблона `Интернет-ссылка`:

```nevod
@шаблон #Интернет-ссылка = Схема + Домен + ?Порт + ?Путь + ?Запрос + ?Якорь;
```

Этот шаблон является целевым, поэтому текст, соответствующий шаблону `Интернет-ссылка`, попадает в результат поиска. Шаблоны `Домен`, `Путь` и `Запрос`, напротив, являются нецелевыми шаблонами, поэтому их совпадения не попадают в результат. Однако пользователь может захотеть узнать, каков домен у соответствующей интернет-ссылки. Можно ли это узнать, не объявляя шаблон `Домен` в качестве самостоятельной цели поиска? Ответ — да, можно. Как раз для этого используются поля.

Шаблон может содержать поля, определенные в круглых скобках сразу после имени шаблона. Давайте, например, воспользуемся полями для извлечения домена, пути, запроса и якоря из интернет-ссылки:

```nevod
@шаблон Интернет-ссылка(домен, путь, запрос, якорь) =
  Схема + домен:Домен + ?Порт + ?путь:Путь + ?запрос:Запрос + ?якорь:Якорь;
```

В этом примере `домен`, `путь`, `запрос` и `якорь` — это поля, которые добавляются в специальный словарь каждого совпадения шаблона `Интернет-ссылка`. Значением поля `домен` становится часть текста, сопадающего с подчинённым шаблоном `Домен`, а значениями полей `путь`, `запрос` и `якорь` становятся части текста, совпадающие соответственно с подчинёнными шаблонами `Путь`, `Запрос` и `Якорь`. Оператор `:` (двоеточие) используется для извлечения совпадающего текста и установки значения поля. Если необязательный подчинённый шаблон пропущен в тексте, соответствующее поле получает пустое значение.

Можно извлекать значения полей из полей подчинённых шаблонов. В следующем примере значение поля `якорь` у шаблона `Интернет-ссылка` извлекается из поля с именем `значение` у подчинённого шаблона `Якорь`:

```nevod
@шаблон Интернет-ссылка(домен, путь, запрос, якорь) =
  Схема + домен:Домен + ?Порт + ?путь:Путь +
  ?запрос:Запрос + ?Якорь(якорь:значение)
@где
{
  Якорь(значение) = '#' + значение:Слово;
};
```

The `Url.Anchor` pattern in the above example contains the `Value` field, which is extracted from text and gets the value of a `Word` after the hash-tag sign. This value is assigned to the `Anchor` field of the `Url` pattern as denoted by the expression `Url.Anchor(Anchor:Value)`.

Шаблон `Интернет-ссылка.Якорь` в приведенном выше примере содержит поле `значение`. В это поле извлекается и сохраняется то слово, что следует в тексте после хэш-тега. Значение поля `значение` присваивается также полю `якорь` при совпадении шаблона `Интернет-ссылка`, на что указывает выражение: `Якорь(якорь:значение)`.

Вы можете извлечь значение поля из текста, а затем сослаться на это поле для поиска ранее извлечённого значения. В следующем примере показано, как эта возможность может быть использована для создания обощённого шаблона, который ищет совпадение с любым HTML-тегом:

```nevod
@шаблон #HTML-тег(~имя) = ('<' + имя:Слово ... '>') ... ('</' + имя + '>');
```

В приведённом выше примере шаблон `HTML-тег` имеет поле `имя`. Знак `~` (тильда) перед именем поля означает, что это внутреннее поле, поэтому его значение не возвращается в результате поиска. Значение поля извлекается из текста как имя открывающего HTML-тега и используется для поиска совпадения с закрывающим HTML-тегом с тем же именем.

## Пространства имён шаблонов

Пространства имён шаблонов позволяют собирать шаблоны в таксономии (иерархические классификаторы) и решают проблему конфликта имён между шаблонами. Пространство имён объявляется с помощью ключевого слова `@пространство`, за которым следует составное имя пространства имён и блок определений шаблонов в фигурных скобках, например:

```nevod
@пространство Основное
{
  @шаблон GUID-идентификатор = Слово(8) + [3 '-' + Слово(4)] + '-' + Слово(12);
  @шаблон GUID-идентификатор-в-скобках = '{' + GUID-идентификатор + '}';
}
```

В примере выше шаблоны `GUID-идентификатор` и `GUID-идентификатор-в-скобках` определены в пространстве имён `Основное`. Эти шаблоны служат для поиска значений GUID-идентификаторов в тексте.

Шаблон, определенный в пространстве имён, получает полное имя, составленное из имени пространства и имени шаблона. В приведённом выше примере полными составными именами шаблонов являются имена `Основное.GUID-идентификатор` и `Основное.GUID-идентификатор-в-скобках` соответственно. Полные имена используются для ссылки на шаблоны из других пространств имён. Для ссылки на шаблон из того же пространства имён можно использовать короткое имя, так, например, шаблон `GUID-идентификатор-в-скобках` ссылается на шаблон `GUID-идентификатор` по короткому имени.

## Пакеты шаблонов

Связанные шаблоны можно сохранить в отдельный файл, называемый пакетом шаблонов или просто пакетом. Рекомендуемые расширения файла: `.невод`, `.nevod`, `.np` (сокращение от Nevod Patterns). Имя файла используется для ссылки на пакет из других пакетов.

Ниже приведён пример пакета:

```nevod
@пространство Основное
{
  @искать @шаблон GUID-идентификатор = Слово(8) + [3 '-' + Слово(4)] + '-' + Слово(12);
}
```

В пакете объявлено пространство имён `Основное` с целевым шаблоном `GUID-идентификатор`. Этот пакет можно сохранить в файл `"GUID.невод"` и потом использовать в других пакетах.

## Использование пакетов шаблонов

Ниже приведён пример второго пакета, который использует первый пакет. Директива `@требуется` обеспечивает подключение требуемого пакета:

```nevod
@требуется "GUID.невод";

@пространство Основное
{
  @искать @шаблон GUID-идентификатор-в-скобках = '{' + GUID-идентификатор + '}';
}
```

Второй пакет использует первый пакет из файла `"GUID.невод"` и добавляет шаблон `GUID-идентификатор-в-скобках` в пространство имён `Основное`. Шаблон `GUID-идентификатор-в-скобках` определён через ссылку на шаблон `GUID-идентификатор`.

Второй пакет может быть сохранен в файл `"GUID-расширения.невод"` и, в свою очередь, использован каким-нибудь третьим пакетом, например:

```nevod
@требуется "GUID.невод";
@требуется "GUID-расширения.невод";

@искать Основное.GUID-идентификатор;
@искать Основное.GUID-идентификатор-в-скобках;
```

Приведённый выше третий пакет не определяет никаких шаблонов, а лишь объявляет шаблоны `Основное.GUID-идентификатор` и `Основное.GUID-идентификатор-в-скобках` в качестве целей поиска.

## Цели поиска

При выполнении поиска на вход движка поиска подаются два основных аргумента: текст и пакет шаблонов. Текст определяет, где искать, а пакет шаблонов определяет, что искать, то есть цели поиска (целевые шаблоны). В результаты поиска включаются совпадения только с целевыми шаблонами.

Обратите внимание, что шаблоны, определённые как цели поиска в используемых пакетах, не рассматриваются автоматически как цели поиска в пакете, подаваемом на вход поиска. Например, поиск с помощью пакета `"GUID-расширения.невод"` означает поиск только шаблона `GUID-идентификатор-в-скобках`, но не шаблона `GUID-идентификатор` в используемом пакете `"GUID.невод"`.

Чтобы выполнить поиск шаблонов из используемых пакетов, объявите их в качестве целей поиска в использующем пакете, например:

```nevod
@требуется "GUID.невод";
@требуется "GUID-расширения.невод";

@искать Основное.GUID-идентификатор;
@искать Основное.GUID-идентификатор-в-скобках;
```

В приведенном выше примере шаблоны `Основное.GUID-идентификатор` и `Основное.GUID-идентификатор-в-скобках` объявлены в качестве целей поиска.

The lists of search targets can be rather long, so it makes sense to use namespace with wildcard syntax to declare all imported target patterns of a given namespace as search targets. For example:

Списки целей поиска могут быть довольно длинными, поэтому имеет смысл использовать пространство имен с групповым символом `*` для объявления всех используемых целевых шаблонов данного пространства имен в качестве целей поиска. Например:

```nevod
@требуется "GUID.невод";
@требуется "GUID-расширения.невод";

@искать Основное.*;
```

Объявление `@искать Основное.*;` означает, что все целевые шаблоны в пространстве имен `Основное` становятся целями поиска. Однако рассматриваются только целевые шаблоны из пакетов, требуемых напрямую; косвенно используемые пакеты не участвуют в формировании целей поиска. Если мы, например, изменим используемый пакет `"GUID.невод"`, подключив к нему другие пакеты с целевыми шаблонами из пространства имён `Основное`, то целевые шаблоны из косвенно используемых пакетов не станут целями поиска.

## Примеры

Ниже приведён пример из основной библиотеки, демонстрирующий извлечение GUID-идентификаторов, хэш-тегов, целых чисел, вещественных чисел, а также процентных значений в тексте:

```nevod
@пространство Основное
{
  @шаблон #GUID = Слово(8) + [3 '-' + Слово(4)] + '-' + Слово(12);
  @шаблон #Хэштег = '#' + {БуквыЦифры, Буквы, '_'} + [0+ {Слово, '_'}];
  @шаблон #Число = {Целое, Вещественное}
  @где
  {
    @шаблон Целое = ?'-' + Цифры @вне Вещественное;
    @шаблон Вещественное = ?{'+', '-'} + Цифры + ?({'.', ','} + Цифры);
  };
  @шаблон #Процент = Цифры + ?Пробел + {'%', 'процент'*};
}
```

Следующий пакет `"Интернет.невод"` демонстрирует шаблон `Интернет-ссылка`, предназначенный для извлечения из текста интернет-ссылок. Он определён через вложенные шаблоны:

```nevod
@пространство Основное
{
  @искать @шаблон Интернет-ссылка(домен, путь, запрос, якорь) =
    Схема + домен:Домен + ?Порт + ?путь:Путь + ?запрос:Запрос +
    ?якорь:Якорь
  @где
  {
    Схема = {'http', 'https' , 'ftp', 'mailto', 'file', 'data',
      'irc'} + '://';
    Домен = Слово + [1+ '.' + Слово + [0+ {Слово, '_', '-'}]];
    Порт = ':' + Цифры;
    Путь = ?'/' + [0+ {Слово, '/', '_', '+', '-', '%', '.'}];

    Запрос = '?' + ?(Параметр + [0+ '&' + Параметр])
    @где
    {
      Параметр = Идентификатор + '=' + Идентификатор
      @где
      {
        Идентификатор = {Буквы, БуквыЦифры, '_'} + [0+ {Слово, '_'}];
      };
    };

    Якорь(значение) = '#' + значение:Слово;
  };
}
```

Следующий пакет демонстрирует шаблон `Адрес-почты`, предназначенный для извлечения из текста почтовых адресов. Он определён через вложенные шаблоны:

```nevod
@требуется "./Интернет.невод";

@пространство Основное
{
  @искать @шаблон Адрес-почты =
    {Локальное-имя, Локальное-имя-в-кавычках} + '@' + Ссылка.Домен
  @где
  {
    Локальное-имя = Слово + [0+
      {Слово, ЗнакПрепинания, Символ, ~Запрещённые-символы, ~[2+ '.'], ~'.@'}]
    @где
    {
      Запрещённые-символы = {'"', '(', ')', ',', ':', ';', '<', '>',
        '@', '[', '\', ']'};
    };
    Локальное-имя-в-кавычках = '"' ... '"';
  };
}
```
